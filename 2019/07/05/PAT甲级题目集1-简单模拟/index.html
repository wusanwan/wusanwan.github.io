<!DOCTYPE html>
<html lang="zh-CN">
    <!-- title -->




<!-- keywords -->




<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="吴三万">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="吴三万">
    
    <meta name="keywords" content="个人博客">
    
    <meta name="description" content="">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <title>PAT甲级题目集1-简单模拟 · 菜鸡小万。</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
        <!-- algolia -->
        <script>
            
            var hits = JSON.parse('{"per_page":10}')
            var labels = JSON.parse('{"input_placeholder":"Search for Posts","hits_empty":"We did not find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}')

            var algolia = {
                applicationID: 'WUWVPBKO6N',
                apiKey: 'e0afed75eb96c871bd883e9bc8eea39c',
                indexName: 'sanw',
                hits: hits,
                labels: labels
            }
        </script>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    
</head>

    
        <body class="post-body">
    
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >菜鸡小万。</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">PAT甲级题目集1-简单模拟</a>
            </div>
    </div>
    
    <a class="home-link" href=/>菜鸡小万。</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
    
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            PAT甲级题目集1-简单模拟
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "算法">算法</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "PAT">PAT</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">12.1k</span>阅读时长: <span class="post-count reading-time">67 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2019/07/05</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>

        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <p>不是按顺序刷的，但是按数字升序排的，有些之前遇到过的问题就不再特地标明了。<br>参考《算法笔记》第三章。<br>[TOC]         </p>
<h1 id="简单模拟"><a href="#简单模拟" class="headerlink" title="简单模拟"></a>简单模拟</h1><hr>
<h2 id="知识要点"><a href="#知识要点" class="headerlink" title="知识要点"></a>知识要点</h2><p>统计数字位数k%10,k/10</p>
<hr>
<h2 id="1002-A-B-for-Polynomials-25"><a href="#1002-A-B-for-Polynomials-25" class="headerlink" title="1002 A+B for Polynomials(25)"></a>1002 A+B for Polynomials(25)</h2><p>This time, you are supposed to find A+B where A and B are two polynomials.<br>Input Specification:</p>
<p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:K N1 aN1 N2 aN2 … NK aNK,where K is the number of nonzero terms in the polynomial, Ni and aNi(i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that 1≤K≤10，0≤NK&lt;…&lt;N2&lt;N1≤1000.<br>Output Specification:</p>
<p>For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.<br>Sample Input:</p>
<blockquote>
<p>2 1 2.4 0 3.2<br>2 2 1.5 1 0.5</p>
</blockquote>
<p>Sample Output:</p>
<blockquote>
<p>3 2 1.5 1 2.9 0 3.2</p>
</blockquote>
<pre><code>  //1002 A+B for Polynomials
  #pragma warning(disable:4996)
  #define eps 1E-6
  #include&lt;cstdio&gt;
  #include&lt;algorithm&gt;
  #include&lt;cmath&gt;
  using namespace std;
  int main(){
      float poly[1001];
      fill(poly, poly + 1001, 0.0);
      int terms, exponent,sumterms=0;
      float cofficient;
      for(int i=0;i&lt;2;i++){
          scanf(&quot;%d&quot;, &amp;terms);
          for (int i = 0; i &lt; terms; i++){
              scanf(&quot; %d %f&quot;, &amp;exponent, &amp;cofficient);
              if (fabs(poly[exponent])&lt;eps&amp;&amp;fabs(cofficient)&gt;eps)sumterms++;
              poly[exponent] += cofficient;
              if (fabs(poly[exponent]) &lt; eps)sumterms--;
          }
      }
      //output
      printf(&quot;%d&quot;, sumterms);
      for (int i = 1000; i &gt;= 0; i--){
          if (fabs(poly[i])&gt;eps)printf(&quot; %.1d %.1f&quot;, i, poly[i]);
      }
      system(&quot;pause&quot;);
      return 0;
  }
</code></pre><p>简单模拟题，思路是抓住多项式相加的本质，项数的话，正负相加相抵消后项数要-1，读入新项要+1，其实也可以全部加完再遍历一遍么。做完这道题的感想是：要好好审题，抓住重点。</p>
<p>注意问题</p>
<ol>
<li>确定浮点数0。  #define eps 1E-6</li>
<li>(审题错误)不限定输入个数的输入处理，while(scanf()!=EOF)(调试的时候换行再ctrl+Z）</li>
</ol>
<hr>
<h2 id="1008-Elevator-20"><a href="#1008-Elevator-20" class="headerlink" title="1008 Elevator(20)"></a>1008 Elevator(20)</h2><p>The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.<br>For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.<br>Input Specification:</p>
<p>Each input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100.<br>Output Specification:</p>
<p>For each test case, print the total time on a single line.<br>Sample Input:</p>
<blockquote>
<p>3 2 3 1</p>
</blockquote>
<p>Sample Output:</p>
<blockquote>
<p>41</p>
</blockquote>
<pre><code>  #pragma warning(disable:4996)
  #include&lt;cstdio&gt;
  #include&lt;vector&gt;
  using namespace std;
  int main(){
      int floor[101];
      floor[0] = 0;  //考虑一开始的情况。
      int N,TotalTime=0,TotalUp=0,TotalDown=0;
      //将问题拆分为上楼和下楼两个过程
      vector&lt;int&gt;up;
      vector&lt;int&gt;down;
      scanf(&quot;%d&quot;, &amp;N);
      for (int i = 1; i &lt; N+1; i++){
          scanf(&quot;%d&quot;, &amp;floor[i]);
          int diff = floor[i] - floor[i - 1];
          if (diff &gt;= 0)
              up.push_back(diff);
          else
              down.push_back(0 - diff);
      }
      for (vector&lt;int&gt;::iterator it = up.begin(); it!= up.end(); it++)
          TotalUp += * it;
      for (vector&lt;int&gt;::iterator it = down.begin(); it!= down.end(); it++)
          TotalDown += * it;
      TotalTime = N * 5 + TotalUp * 6 + TotalDown * 4;
      printf(&quot;%d&quot;, TotalTime);
      //system(&quot;pause&quot;);
      return 0;
  }
</code></pre><p>简单题，思路是把过程拆分为上楼和下楼两个过程，分别进行计算。但代码不够精炼，push进vector的步骤还不如直接计算所需时间了,浪费时间空间复杂度。（我就是想用vector试试看）</p>
<ol>
<li>vs2013的scanf报错问题<br>要么加上  #pragma warning(disable:4996)，要么每次提交的时候把_s删掉。   </li>
<li>尽可能精炼。   </li>
</ol>
<hr>
<h2 id="1009-Product-of-Polynomials-25"><a href="#1009-Product-of-Polynomials-25" class="headerlink" title="1009 Product of Polynomials(25)"></a>1009 Product of Polynomials(25)</h2><p>This time, you are supposed to find A×B where A and B are two polynomials.<br>Input Specification:</p>
<p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:K N1 aN1 N2 aN2 … NK aNK,where K is the number of nonzero terms in the polynomial, Ni and aNi(i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that 1≤K≤10，0≤NK&lt;…&lt;N2&lt;N1≤1000.<br>Output Specification:</p>
<p>For each test case you should output the product of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate up to 1 decimal place.<br>Sample Input:</p>
<blockquote>
<p>2 1 2.4 0 3.2<br>2 2 1.5 1 0.5</p>
</blockquote>
<p>Sample Output:</p>
<blockquote>
<p>3 3 3.6 2 6.0 1 1.6</p>
</blockquote>
<pre><code>  //1009 Product of Polynomials
  #pragma warning(disable:4996)
  #define eps 1E-6
  #include&lt;cstdio&gt;
  #include&lt;algorithm&gt;
  #include&lt;cmath&gt;
  using namespace std;
  struct poly{
      int term;
      int exponent[10];
      float cofficient[10];
  };
  int main(){
      float result[2001];
      fill(result, result + 2001, 0.0);
      int _term,_exponent,sumterms=0;//_表示是第二个
      poly first;
      float _cofficient;
      scanf(&quot;%d&quot;, &amp;first.term);
      for (int i = 0; i &lt;first.term; i++){
          scanf(&quot; %d %f&quot;, &amp;first.exponent[i], &amp;first.cofficient[i]);
      }
      scanf(&quot;%d&quot;, &amp;_term);
      for (int i = 0; i&lt;_term; i++){
          scanf(&quot; %d %f&quot;, &amp;_exponent, &amp;_cofficient);
          for (int j = 0; j &lt; first.term; j++){
              result[_exponent + first.exponent[j]]+= _cofficient*first.cofficient[j];
          }
      }
      //统计总数
      for (int i = 0; i&lt;2001; i++)
          if (fabs(result[i])&gt;eps)sumterms++;
      //output
      printf(&quot;%d&quot;, sumterms);
      for (int i = 2000; i &gt;= 0; i--){
          if (fabs(result[i])&gt;eps)printf(&quot; %.1d %.1f&quot;, i, result[i]);
      }
      system(&quot;pause&quot;);
      return 0;
  }
</code></pre><p>思路：存一组多项式，另一组边读入边进行计算，最后遍历统计项数。</p>
<ol>
<li>要注意这边乘的话范围变了。</li>
</ol>
<hr>
<h2 id="1011-World-Cup-Betting-20"><a href="#1011-World-Cup-Betting-20" class="headerlink" title="1011 World Cup Betting(20)"></a>1011 World Cup Betting(20)</h2><p>With the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets.<br>Chinese Football Lottery provided a “Triple Winning” game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results — namely W for win, T for tie, and L for lose. There was an odd assigned to each result. The winner’s odd would be the product of the three odds times 65%.<br>For example, 3 games’ odds are given as the following:</p>
<blockquote>
<p>W    T    L<br>1.1  2.5  1.7<br>1.2  3.1  1.6<br>4.1  1.2  1.1</p>
</blockquote>
<p>To obtain the maximum profit, one must buy W for the 3rd game, T for the 2nd game, and T for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.1×3.1×2.5×65%−1)×2=39.31 yuans (accurate up to 2 decimal places).<br>Input Specification:</p>
<p>Each input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to W, T and L.<br>Output Specification:</p>
<p>For each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space.<br>Sample Input:</p>
<blockquote>
<p>1.1 2.5 1.7<br>1.2 3.1 1.6<br>4.1 1.2 1.1</p>
</blockquote>
<p>Sample Output:</p>
<blockquote>
<p>T T W 39.31</p>
</blockquote>
<pre><code>//1011 World Cup Betting （20 分）
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#pragma warning(disable:4996)
int main(){
    float odds[3][3], product = 1;
    int decision[3];
    fill(decision, decision + 3, 0);//语法上也是左闭右开
    char a[4] = &quot;WTL&quot;; //记得留一个空
    for (int i = 0; i &lt; 3; i++){
        for (int j = 0; j &lt; 3; j++){
            scanf(&quot;%f&quot;, &amp;odds[i][j]);
            if (odds[i][decision[i]] &lt; odds[i][j])decision[i] = j;
        }
        product *= odds[i][decision[i]];
        printf(&quot;%c&quot;,a[decision[i]]);
    }
    printf(&quot;%.2f&quot;, product*0.65*2 - 2);
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>思路：每行边读边找最大值，太简单了没啥好说的，记得scanf加&amp;。</p>
<ol>
<li>LTW那段还是可以写成char a[4]=”WTL”,就是最简单的数字字符映射啦！（以后再一个个打if我是猪）</li>
<li>字符串记得要空一个</li>
</ol>
<hr>
<h2 id="1036-Boys-vs-Girls-25"><a href="#1036-Boys-vs-Girls-25" class="headerlink" title="1036 Boys vs Girls(25)"></a>1036 Boys vs Girls(25)</h2><p>1036 Boys vs Girls （25 分）<br>This time you are asked to tell the difference between the lowest grade of all the male students and the highest grade of all the female students.<br>Input Specification:</p>
<p>Each input file contains one test case. Each case contains a positive integer N, followed by N lines of student information. Each line contains a student’s name, gender, ID and grade, separated by a space, where name and ID are strings of no more than 10 characters with no space, gender is either F (female) or M (male), and grade is an integer between 0 and 100. It is guaranteed that all the grades are distinct.</p>
<p>Output Specification:</p>
<p>For each test case, output in 3 lines. The first line gives the name and ID of the female student with the highest grade, and the second line gives that of the male student with the lowest grade. The third line gives the difference gradeF−gradeM . If one such kind of student is missing, output Absent in the corresponding line, and output NA in the third line instead.</p>
<p>Sample Input 1:</p>
<blockquote>
<p>3<br>Joe M Math990112 89<br>Mike M CS991301 100<br>Mary F EE990830 95</p>
</blockquote>
<p>Sample Output 1:</p>
<blockquote>
<p>Mary EE990830<br>Joe Math990112<br>6</p>
</blockquote>
<p>Sample Input 2:</p>
<blockquote>
<p>1<br>Jean M AA980920 60</p>
</blockquote>
<p>Sample Output 2:</p>
<blockquote>
<p>Absent<br>Jean AA980920<br>NA</p>
</blockquote>
<pre><code>    //1036 Boys vs Girls （25 分）
    #pragma warning(disable:4996)
    #include&lt;stdio.h&gt;
    #include&lt;stdlib.h&gt;
    struct student{
        char name[11];
        char gender;
        char ID[11];
        int grade;
    };
    int main(){
        int N,boy=1000,girl=1001;
        student stu[1002];
        scanf(&quot;%d&quot;, &amp;N);
        //设置了两个假人
        stu[1000].gender = &#39;M&#39;;
        stu[1000].grade = 101;
        stu[1001].gender = &#39;F&#39;;
        stu[1001].grade = -1;
        for (int i = 0; i &lt; N; i++){
            scanf(&quot;%s %c %s %d&quot;, &amp;stu[i].name, &amp;stu[i].gender, &amp;stu[i].ID, &amp;stu[i].grade);
            if (stu[i].gender == &#39;M&#39;&amp;&amp;stu[i].grade &lt; stu[boy].grade)boy = i;
            if (stu[i].gender == &#39;F&#39;&amp;&amp;stu[i].grade &gt; stu[girl].grade)girl = i;
        }
        //output
        if (girl == 1001)printf(&quot;Absent\n&quot;);
        else printf(&quot;%s %s\n&quot;, stu[girl].name, stu[girl].ID);
        if(boy == 1000)printf(&quot;Absent\n&quot;);
        else printf(&quot;%s %s\n&quot;, stu[boy].name, stu[boy].ID);
        if (girl == 1001 || boy == 1000)printf(&quot;NA&quot;);
        else printf(&quot;%d&quot;, stu[girl].grade - stu[boy].grade);
        system(&quot;pause&quot;);
        return 0;
    }
</code></pre><p>简单题。思路：设置结构体，边读边比较，设置假人检定有无。</p>
<ol>
<li>也可以边读边比，只存储当前的最值数据，记录下男女生人数。</li>
<li>从最值成绩的角度看，也可以再存储一个最值成绩进行比较，这样就不用设假人定初值了。</li>
</ol>
<hr>
<h2 id="1042-Shuffling-Machine-20"><a href="#1042-Shuffling-Machine-20" class="headerlink" title="1042 Shuffling Machine(20)"></a>1042 Shuffling Machine(20)</h2><p>Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid “inside jobs” where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ automatic shuffling machines. Your task is to simulate a shuffling machine.<br>The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order:<br>S1, S2, …, S13,<br>H1, H2, …, H13,<br>C1, C2, …, C13,<br>D1, D2, …, D13,<br>J1, J2<br>where “S” stands for “Spade”, “H” for “Heart”, “C” for “Club”, “D” for “Diamond”, and “J” for “Joker”. A given order is a permutation of distinct integers in [1, 54]. If the number at the i-th position is j, it means to move the card from position i to position j. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13.<br>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains a positive integer K (≤20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space.<br>Output Specification:</p>
<p>For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line.</p>
<p>Sample Input:</p>
<blockquote>
<p>2<br>36 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47</p>
</blockquote>
<p>Sample Output:</p>
<blockquote>
<p>S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5</p>
</blockquote>
<pre><code>//1042 Shuffling Machine
#include&lt;cstdio&gt;
#include &lt;stdlib.h&gt;
using namespace std;
void shuffle(int order[], int result[], int RepeatTime){
    //order是给定循环顺序，result是对应序号所在位置。
    //初始化
    for (int i = 0; i &lt; 54; i++)
        result[i] = i;
    //shuffle
    for (int i = 1; i &lt;= RepeatTime; i++){
        for (int j = 0; j &lt; 54; j++){
            result[j] = order[result[j]]-1;//注意给的order是和数组序号不对应的
        }
    }
}
int main(){
    //input
    int RepeatTime;
    scanf(&quot;%d&quot;, &amp;RepeatTime);
    int order[54];
    for (int i = 0; i &lt; 54; i++){
        scanf(&quot;%d&quot;, &amp;order[i]);
    }
    //shuffling
    int result[54];
    shuffle(order, result, RepeatTime);
    //output 其实也可以考虑写结构体,二维数组什么的，因为54不算大这里就直接搞了。
    for (int i = 0; i &lt; 54; i++){
        int pos;
        for (int j = 0; j &lt; 54; j++){//寻找位置
            if (result[j] == i) {
                pos = j;
                break;
            }
        }
        if (0 &lt;= pos &amp;&amp; pos &lt; 13)            //别写成0 &lt;= pos &lt; 13了！！
            printf(&quot;S%d&quot;, pos + 1);
        else if (13 &lt;= pos &amp;&amp; pos &lt; 26)
            printf(&quot;H%d&quot;, pos - 12);
        else if (26 &lt;= pos&amp;&amp; pos  &lt; 39)
            printf(&quot;C%d&quot;, pos - 25);
        else if (39 &lt;= pos &amp;&amp; pos &lt; 52)
            printf(&quot;D%d&quot;, pos - 38);
        else
            printf(&quot;J%d&quot;, pos - 51);
        if (i != 53)printf(&quot; &quot;);//追加空格
    }
    system(&quot;pause&quot;);  //找不到标识符 include#include &lt;stdlib.h&gt;
    return 0;
}
</code></pre><p>简单模拟题，思路是不停循环得出结果数组result,其中index代表具体的牌，result[index]代表某张牌所处位置，最后再循环遍历数组，根据result[index]值的顺序进行输出。这里基于牌数是54写得比较简单了点，要是牌数一多可以写成结构体，二维数组之类的，可根据result的位置值直接进行sort输出而不是每次输出都遍历数组寻找，输出也可以写成char a[6]=”SHCDJ”，再把数字对应到牌上。所以暴露的问题是程序不够结构化？</p>
<ol>
<li>找不到标识符system<br>include<stdlib.h></stdlib.h></li>
<li>注意区间要写成（a&lt;x&amp;&amp;x&lt;b)的形式。</li>
<li>尽可能结构化。</li>
</ol>
<hr>
<h2 id="1046-Shortest-Distance-20"><a href="#1046-Shortest-Distance-20" class="headerlink" title="1046 Shortest Distance(20)"></a>1046 Shortest Distance(20)</h2><p>The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.<br>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains an integer N (in [3,10^5]), followed by N integer distances D1,D2……DN,where Di is the distance between the i-th and the (i+1)-st exits, and DN is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (≤10<br>​4), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 10<br>​7.<br>Output Specification:<br>For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits.</p>
<p>Sample Input:</p>
<blockquote>
<p>5 1 2 4 14 9<br>3<br>1 3<br>2 5<br>4 1</p>
</blockquote>
<p>Sample Output:</p>
<blockquote>
<p>3<br>10<br>7</p>
</blockquote>
<pre><code>//1046 Shortest Distance （20 分）
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std; //用库千万别忘
int ShortestDistances(int mark[], int start, int end,int length){
    int leftway=0, rightway=0;
    if (start &gt; end)swap(start, end);
    if (start == end)return 0;
    rightway = mark[end - 1] - mark[start - 1];
    leftway = length - rightway;
    return min(leftway, rightway);
}
int main(){
    //input
    int exits,questions,length=0;
    scanf(&quot;%d&quot;, &amp;exits);
    int circle[100000];
    int mark[100001];
    mark[0] = 0;
    for (int i = 0; i &lt; exits; i++){
        scanf(&quot;%d&quot;, &amp;circle[i]);
        mark[i+1] = mark[i] + circle[i];
    }
    length = mark[exits];
    scanf(&quot;%d&quot;, &amp;questions);
    //process
    for (int i = 0; i &lt; questions; i++){
        int start, end;
        scanf(&quot;%d %d&quot;, &amp;start,&amp;end);
        printf(&quot;%d\n&quot;, ShortestDistances(mark,start,end,length));
    }
    //system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>模拟题，难点在容易超时。最简单的思路应该是顺时针逆时针分别累加，优化时间有2个方面，1是因为是一个圆所以只要算出一条路的，另一条路只要用周长相减即可，这个如果用草稿纸画一画会很容易想到。2是累加还是费时间，最耗费时间的情况下应该是要循环(exits-1)*questions,算O(n^2)了，可以在之前读入的循环里把每个点到1的距离算出来作为度量，相当于把圆环剪开，用的时候只需相减即可，这里就是mark相减，这样时间复杂度就是O(n)。</p>
<ol>
<li>考虑题目的特点，必要时多画一画，通过更改度量简化时间复杂度。</li>
<li>用各种库的时候要记得using namespace std;</li>
<li>看了下官方FAQ，好像system(“pause”)也会造成超时，之前的提交中我是没遇到……</li>
<li>也是官方FAQ，说是不能用中文注释，这个我也没遇到……</li>
</ol>
<hr>
<h2 id="1049-Counting-Ones-30"><a href="#1049-Counting-Ones-30" class="headerlink" title="1049 Counting Ones(30)"></a>1049 Counting Ones(30)</h2><p>The task is simple: given any positive integer N, you are supposed to count the total number of 1’s in the decimal form of the integers from 1 to N. For example, given N being 12, there are five 1’s in 1, 10, 11, and 12.<br>Input Specification:<br>Each input file contains one test case which gives the positive N (≤2^​30).</p>
<p>Output Specification:<br>For each test case, print the number of 1’s in one line.</p>
<p>Sample Input:<br>12</p>
<p>Sample Output:<br>5</p>
<p>这道题我自己的思路是这样的：<strong>把数字拆成若干个10的n次方</strong>。<br>举个例子 234：0-199,200-229,230-234，在后面数字无1的情况下，可看成0-199,0-29，0-4。</p>
<ol>
<li>以10的n次方-1为最小单位。即0-9,0-99,0-999…其中每个单位中1的数目记为count[i]。count[i]=count[i-1]*10+10^i; 比如0-99里有10个0-9，再加上10-19里面的10^1个1，0-999里就是10个0-99+10 ^2。</li>
<li>求得每个单位的数值后，数值大于1的就用数值乘以单位的值，再加上10的i次方。比如0-79里有8个0-9+10-19里面的1^10个1。数值等于1的，就是拿count[i-1]：0-9就是拿count[0]。</li>
<li>因为这种等价转换是在没有数位为1的情况下做出的，所以对有1的情况进行补充。如13，按照前文分析应该为0-9和0-3,1的部分给了count[0]即1个1,3的部分给了1个1，可见10,11,12,13十位（即为1的位）上的1缺了后面数字+1个1。比如134就是缺了34+1个1。</li>
</ol>
<p>将以上破烂逻辑转换成破烂代码是这样的。</p>
<pre><code>//1049 Counting Ones （30 分）自己的破烂逻辑
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#pragma warning(disable:4996)
using namespace std;
int main(){
    int N,result=0;
    scanf(&quot;%d&quot;, &amp;N);
    int counts[10];//0-10^index-1,10^index算在1里面
    counts[0] = 1;
    int value[10],IsOne[10];
    fill(IsOne, IsOne + 10, 0);
    for (int i = 1; i&lt;10; i++)
        counts[i] = counts[i - 1] * 10 + pow(10, i);
    for (int i = 9; i &gt; 0; i--){//计算每位上的值,个位就是N了
        value[i] = N / pow(10, i);
        N = N - value[i] * pow(10, i);
        if (value[i] &gt; 1){
            result += counts[i - 1] * value[i]+ pow(10,i);
        }
        if (value[i] == 1){
            result += counts[i - 1];
            IsOne[i] =1;
        }
    }
    //计算个位数
    if(N &gt;= 1)result++;
    //追加因为1造成的增加
    int temp=N;
    for (int i = 1; i &lt; 10; i++){
        if (IsOne[i])result = temp + result +1;
        temp += value[i] * pow(10, i);
    }
    printf(&quot;%d&quot;, result);
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>深化的思路：<a href="https://blog.csdn.net/SJF0115/article/details/8600599" target="_blank" rel="noopener">https://blog.csdn.net/SJF0115/article/details/8600599</a><br>这种思路是<strong>把1的个数分摊到每个数位上进行计算</strong>，而每个数位上1的个数和它本身，它之前之后的数相关，简洁明了！厉害！<br>用这种逻辑也写了一版代码。</p>
<pre><code>//1049 Counting Ones （30 分） 向前向后版
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;cmath&gt;
#pragma warning(disable:4996)
using namespace std;
int main(){
    int N, result = 0, digit = 9,high=0,low;
    scanf(&quot;%d&quot;, &amp;N);
    int value[10];
    low = N;
    for (int i = 9; i &gt;=0; i--){//计算每位的值
        value[i] = low / pow(10, i);
        result += high * pow(10,i);
        high = high * 10 + value[i];
        low -= pow(10, i)*value[i];
        if (value[i] &gt; 1){
            result += pow(10, i);
        }
        else if (value[i] == 1){
            result += low;
            result++;
        }
        else{
            continue;
        }
    }
    printf(&quot;%d&quot;, result);
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><hr>
<h2 id="1069-The-Black-Hole-of-Numbers-20"><a href="#1069-The-Black-Hole-of-Numbers-20" class="headerlink" title="1069 The Black Hole of Numbers(20)"></a>1069 The Black Hole of Numbers(20)</h2><p>For any 4-digit integer except the ones with all the digits being the same, if we sort the digits in non-increasing order first, and then in non-decreasing order, a new number can be obtained by taking the second number from the first one. Repeat in this manner we will soon end up at the number 6174 — the black hole of 4-digit numbers. This number is named Kaprekar Constant.<br>For example, start from 6767, we’ll get:<br>7766 - 6677 = 1089<br>9810 - 0189 = 9621<br>9621 - 1269 = 8352<br>8532 - 2358 = 6174<br>7641 - 1467 = 6174<br>… …<br>Given any 4-digit number, you are supposed to illustrate the way it gets into the black hole.<br>Input Specification:<br>Each input file contains one test case which gives a positive integer N in the range (0,10<br>​^4​ ).<br>Output Specification:<br>If all the 4 digits of N are the same, print in one line the equation N - N = 0000. Else print each step of calculation in a line until 6174 comes out as the difference. All the numbers must be printed as 4-digit numbers.</p>
<p>Sample Input 1:</p>
<blockquote>
<p>6767</p>
</blockquote>
<p>Sample Output 1:</p>
<blockquote>
<p>7766 - 6677 = 1089<br>9810 - 0189 = 9621<br>9621 - 1269 = 8352<br>8532 - 2358 = 6174</p>
</blockquote>
<p>Sample Input 2:</p>
<blockquote>
<p>2222</p>
</blockquote>
<p>Sample Output 2:</p>
<blockquote>
<p>2222 - 2222 = 0000</p>
</blockquote>
<pre><code>//1069 The Black Hole of Numbers
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
int main(){
    int origin;
    scanf_s(&quot;%d&quot;, &amp;origin);
    int flag = 0;
    int pos[4];
    do {
        for (int i = 0; i &lt; 4; i++){
            pos[i] = origin / pow(10, 3 - i);
            origin -= pos[i] * pow(10, 3 - i);
        }
        int bigger = 0, smaller = 0;
        sort(pos, pos + 4);
        for (int i = 0; i &lt; 4; i++){
            smaller += pos[i] * pow(10, 3 - i);
            bigger += pos[i] * pow(10, i);
        }
        int diff = bigger - smaller;
        printf(&quot;%04d - %04d = %04d\n&quot;, bigger, smaller, diff);  //用%0md补足零
        if (diff == 0 || diff == 6174)flag = 1;
        else origin = diff;
    } while (!flag);
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>简单题 。</p>
<ol>
<li>用%0md补足零。</li>
</ol>
<hr>
<h2 id="1093-Count-PAT’s-25"><a href="#1093-Count-PAT’s-25" class="headerlink" title="1093 Count PAT’s (25)"></a>1093 Count PAT’s (25)</h2><p>The string APPAPT contains two PAT’s as substrings. The first one is formed by the 2nd, the 4th, and the 6th characters, and the second one is formed by the 3rd, the 4th, and the 6th characters.<br>Now given any string, you are supposed to tell the number of PAT’s contained in the string.</p>
<p>Input Specification:<br>Each input file contains one test case. For each case, there is only one line giving a string of no more than 10^5<br>​​  characters containing only P, A, or T.</p>
<p>Output Specification:<br>For each test case, print in one line the number of PAT’s contained in the string. Since the result may be a huge number, you only have to output the result moded by 1000000007.</p>
<p>Sample Input:</p>
<blockquote>
<p>APPAPT</p>
</blockquote>
<p>Sample Output:</p>
<blockquote>
<p>2</p>
</blockquote>
<pre><code>//1093 Count PAT&#39;s
#pragma warning(disable:4996)
#include&lt;cstdio&gt;
#include&lt;string&gt;
#include&lt;cstdlib&gt;
#include&lt;iostream&gt;
using namespace std;
int main(){
    string str;
    cin &gt;&gt; str;
    long long a = 0, t = 0, sumP=0,sumA=0;
    for (int i = str.length() - 1; i &gt;= 0; i--){
        if (str[i] == &#39;T&#39;){//当前T的数目
            t++;
        }
        else if (str[i] == &#39;A&#39;){//对于当前这个A而言，T有几个就有几种AT的可能
            sumA += t;//sumA 表示当前所有AT组合的数目
        }
        else if (str[i] == &#39;P&#39;){//对于当前这个P而言，AT有几个就有几种PAT的可能
            sumP += sumA;//sumP 表示当前所有PAT组合的数目
        }
        else
            continue;
    }
    printf(&quot;%lld&quot;, sumP % 1000000007);
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>思路：从右往左遍历，然后……看注释。这是P定结果的，看别人答案也可以对于每个A，计算前后的P和T的数目相乘。</p>
<hr>
<h2 id="1104-Sum-of-Number-Segments-20"><a href="#1104-Sum-of-Number-Segments-20" class="headerlink" title="1104 Sum of Number Segments(20)"></a>1104 Sum of Number Segments(20)</h2><p>Given a sequence of positive numbers, a segment is defined to be a consecutive subsequence. For example, given the sequence { 0.1, 0.2, 0.3, 0.4 }, we have 10 segments: (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) and (0.4).<br>Now given a sequence, you are supposed to find the sum of all the numbers in all the segments. For the previous example, the sum of all the 10 segments is 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0.<br>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N, the size of the sequence which is no more than 10<br>​5<br>​​ . The next line contains N positive numbers in the sequence, each no more than 1.0, separated by a space.<br>Output Specification:</p>
<p>For each test case, print in one line the sum of all the numbers in all the segments, accurate up to 2 decimal places.<br>Sample Input:</p>
<blockquote>
<p>4<br>0.1 0.2 0.3 0.4</p>
</blockquote>
<p>Sample Output:</p>
<blockquote>
<p>5.00</p>
</blockquote>
<pre><code>//1104 Sum of Number Segments （20 分）
#include&lt;cstdio&gt;
#include&lt;stdlib.h&gt;
#pragma warning(disable:4996)
int main(){
    int N;//本质不是怎么排序而是0.1，0.2，0.3，0.4这种各出现几次
    float temp,sum = 0;
    scanf(&quot;%d&quot;, &amp;N);
    for (int i = 0; i &lt; N; i++){
        scanf(&quot;%f&quot;, &amp;temp);
        sum += temp*(N - i)*(i + 1);
    }
    printf(&quot;%.2f&quot;, sum);
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>思路：简单数学规律题，找到规律即可，用float会通不过，以后用double了。</p>
<hr>
<h2 id="1109-Group-Photo-25"><a href="#1109-Group-Photo-25" class="headerlink" title="1109 Group Photo(25)"></a>1109 Group Photo(25)</h2><p>Formation is very important when taking a group photo. Given the rules of forming K rows with N people as the following:<br>The number of people in each row must be N/K (round down to the nearest integer), with all the extra people (if any) standing in the last row;<br>All the people in the rear row must be no shorter than anyone standing in the front rows;<br>In each row, the tallest one stands at the central position (which is defined to be the position (m/2+1), where m is the total number of people in that row, and the division result must be rounded down to the nearest integer);<br>In each row, other people must enter the row in non-increasing order of their heights, alternately taking their positions first to the right and then to the left of the tallest one (For example, given five people with their heights 190, 188, 186, 175, and 170, the final formation would be 175, 188, 190, 186, and 170. Here we assume that you are facing the group so your left-hand side is the right-hand side of the one at the central position.);<br>When there are many people having the same height, they must be ordered in alphabetical (increasing) order of their names, and it is guaranteed that there is no duplication of names.<br>Now given the information of a group of people, you are supposed to write a program to output their formation.</p>
<p>Input Specification:<br>Each input file contains one test case. For each test case, the first line contains two positive integers N (≤10^4<br>), the total number of people, and K (≤10), the total number of rows. Then N lines follow, each gives the name of a person (no more than 8 English letters without space) and his/her height (an integer in [30, 300]).</p>
<p>Output Specification:<br>For each case, print the formation — that is, print the names of people in K lines. The names must be separated by exactly one space, but there must be no extra space at the end of each line. Note: since you are facing the group, people in the rear rows must be printed above the people in the front rows.</p>
<p>Sample Input:</p>
<blockquote>
<p>10 3<br>Tom 188<br>Mike 170<br>Eva 168<br>Tim 160<br>Joe 190<br>Ann 168<br>Bob 175<br>Nick 186<br>Amy 160<br>John 159</p>
</blockquote>
<p>Sample Output:</p>
<blockquote>
<p>Bob Tom Joe Nick<br>Ann Mike Eva<br>Tim Amy John</p>
</blockquote>
<pre><code>//1109 Group Photo
#include&lt;cstdio&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
#pragma warning(disable:4996)
struct person{
    char name[12];
    int height;
};
bool cmp(person a, person b){//
    if (a.height == b.height &amp;&amp; strcmp(b.name, a.name)&gt;0)return true;
    else return a.height &gt; b.height;
}
int main(){
    int N, K,first,last,count=0;
    scanf(&quot;%d %d&quot;, &amp;N, &amp;K);
    person list[10100];
    int pos[10100];
    for (int i = 0; i &lt; N; i++)
        scanf(&quot;%s %d&quot;, &amp;list[i].name, &amp;list[i].height);
    sort(list, list + N, cmp);
    first = round(N / K);
    last = N - first * (K-1);
    for (int i= 0; i &lt; K; i++){//对于每行
        int center,rowK;
        if (!i)rowK = last;//选择队列长度
        else rowK = first;
        center = rowK / 2 ; //选择队列中心
        for (int j = 0; j &lt; rowK; j++){//安排位置顺序
            center += pow(-1, j)*j;
            pos[center] = j;
        }
        for (int j = 0; j &lt; rowK; j++){//输出安排
            if (j == rowK - 1)printf(&quot;%s&quot;, list[pos[j] + count].name);
            else printf(&quot;%s &quot;,list[pos[j]+count].name);
        }
        printf(&quot;\n&quot;);
        count += rowK;
    }
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>思路：先确定每排人数，再对人进行排序，按照排进行分割，在每个小区间内再次进行排序。</p>
<hr>
<h2 id="1113-Integer-Set-Partition-25"><a href="#1113-Integer-Set-Partition-25" class="headerlink" title="1113 Integer Set Partition (25)"></a>1113 Integer Set Partition (25)</h2><p>Given a set of N (&gt;1) positive integers, you are supposed to partition them into two disjoint sets A1 and A2 of n1 and n2 numbers,respectively.let S1 and S2 denote the sums of all the numbers in A1 and A2,respectively. You are supposed to make the partition so that | n1-n2| is minimized first, and then | S1-S2| is maximumed.<br>​<br>Input Specification:<br>Each input file contains one test case. For each case, the first line gives an integer N (2≤N≤10^5​​ ), and then N positive integers follow in the next line, separated by spaces. It is guaranteed that all the integers and their sum are less than 2^31.</p>
<p>Output Specification:<br>For each case, print in a line two numbers: |n1-n2| and |s1-s2|, separated by exactly one space.</p>
<p>Sample Input 1:</p>
<blockquote>
<p>10<br>23 8 10 99 46 2333 46 1 666 555</p>
</blockquote>
<p>Sample Output 1:</p>
<blockquote>
<p>0 3611</p>
</blockquote>
<p>Sample Input 2:</p>
<blockquote>
<p>13<br>110 79 218 69 3721 100 29 135 2 6 13 5188 85</p>
</blockquote>
<p>Sample Output 2:</p>
<blockquote>
<p>1 9359</p>
</blockquote>
<pre><code>//1113 Integer Set Partition
#pragma warning(disable:4996)
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
    int N,clip,s1=0,s2=0,j;
    scanf(&quot;%d&quot;, &amp;N);
    int list[100000];
    for (int i = 0; i &lt; N; i++)
        scanf(&quot;%d&quot;, &amp;list[i]);
    sort(list, list + N);
    clip= ceil(N / 2.0);    //注意这里是N/2.0
    for (j = 0; j &lt; N - clip; j++)
        s1 += list[j];
    for (; j &lt; N; j++)
        s2 += list[j];
    printf(&quot;%d %d&quot;, 2 * clip - N, abs(s2 - s1));
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>简单题，这里2*clip-N其实就是N%2.</p>
<hr>
<h2 id="1117-Eddington-Number-25"><a href="#1117-Eddington-Number-25" class="headerlink" title="1117 Eddington Number(25)"></a>1117 Eddington Number(25)</h2><p>British astronomer Eddington liked to ride a bike. It is said that in order to show off his skill, he has even defined an “Eddington number”, E — that is, the maximum integer E such that it is for E days that one rides more than E miles. Eddington’s own E was 87.<br>Now given everyday’s distances that one rides for N days, you are supposed to find the corresponding E (≤N).<br>Input Specification:<br>Each input file contains one test case. For each case, the first line gives a positive integer N (≤10^5), the days of continuous riding. Then N non-negative integers are given in the next line, being the riding distances of everyday.</p>
<p>Output Specification:<br>For each case, print in a line the Eddington number for these N days.<br>Sample Input:</p>
<blockquote>
<p>10<br>6 7 6 9 3 10 8 2 7 8</p>
</blockquote>
<p>Sample Output:</p>
<blockquote>
<p>6</p>
</blockquote>
<pre><code>//1117 Eddington Number
#pragma warning(disable:4996)
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
    int rides[100000];//int有10^9
    int N;
    scanf(&quot;%d&quot;, &amp;N);
    for (int i = 0; i &lt; N; i++)
        scanf(&quot;%d&quot;, &amp;rides[i]);
    sort(rides, rides + N);//默认递增排序
    int i;
    for (i = N; i &gt;= 0; i--){
        if (rides[N-i]&gt;i)break;
    }
    if (i==-1)printf(&quot;0&quot;);
    else printf(&quot;%d&quot;, i);
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>  简单题，主要还是得理解题目意思，思路是排序然后倒序找E的值。</p>
<ol>
<li>因为眼瞎没看见范围，解锁了段错误，原来段错误是开的数组太小的问题。</li>
<li>得考虑特殊情况全是0不出门的日子。</li>
<li>int有10的9次方。</li>
<li>sort默认增序。</li>
</ol>
<hr>
<h2 id="1128-N-Queens-Puzzle-20"><a href="#1128-N-Queens-Puzzle-20" class="headerlink" title="1128 N Queens Puzzle(20)"></a>1128 N Queens Puzzle(20)</h2><p> The “eight queens puzzle” is the problem of placing eight chess queens on an 8×8 chessboard so that no two queens threaten each other. Thus, a solution requires that no two queens share the same row, column, or diagonal. The eight queens puzzle is an example of the more general N queens problem of placing N non-attacking queens on an N×N chessboard. (From Wikipedia - “Eight queens puzzle”.)<br>  Here you are NOT asked to solve the puzzles. Instead, you are supposed to judge whether or not a given configuration of the chessboard is a solution. To simplify the representation of a chessboard, let us assume that no two queens will be placed in the same column. Then a configuration can be represented by a simple integer sequence (Q1,Q2,,⋯,QN), where Q​i is the row number of the queen in the i-th column. For example, Figure 1 can be represented by (4, 6, 8, 2, 7, 1, 3, 5) and it is indeed a solution to the 8 queens puzzle; while Figure 2 can be represented by (4, 6, 7, 2, 8, 1, 9, 5, 3) and is NOT a 9 queens’ solution.</p>
<p>  Input Specification:</p>
<p>  Each input file contains several test cases. The first line gives an integer K (1&lt;K≤200). Then K lines follow, each gives a configuration in the format “N Q1 Q2  … QN”, where 4≤N≤1000 and it is guaranteed that 1≤Q​i≤N for all i=1,⋯,N. The numbers are separated by spaces.</p>
<p>  Output Specification:<br>    For each configuration, if it is a solution to the N queens problem, print YES in a line; or NO if not.</p>
<p>  Sample Input:</p>
<blockquote>
<p>4<br>  8 4 6 8 2 7 1 3 5<br>  9 4 6 7 2 8 1 9 5 3<br>  6 1 5 2 6 4 3<br>  5 1 3 5 2 4</p>
</blockquote>
<p>  Sample Output:</p>
<blockquote>
<p> YES<br>  NO<br>  NO<br>  YES</p>
</blockquote>
<pre><code>//1128 N Queens Puzzle
#include&lt;cstdio&gt;
#include&lt;stdlib.h&gt;
#pragma warning(disable:4996)
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
bool IsNQueen(int queen[], int num){
    for (int i = 0; i &lt; num - 1; i++)//diag
        for (int j = i + 1; j &lt; num; j++)
            if (j - i == abs(queen[i] - queen[j]))return false;
    sort(queen, queen + num);
    for (int i = 0; i &lt; num - 1; i++)if (queen[i] == queen[i + 1])return false;//equal row
    return true;
}
int main(){
    int N;
    int queen[200][1000];
    int num[200];
    scanf(&quot;%d&quot;, &amp;N);
    for (int i = 0; i &lt; N; i++){
        scanf(&quot;%d&quot;, &amp;num[i]);
        for (int j = 0; j &lt; num[i]; j++){
            scanf(&quot;%d&quot;, &amp;queen[i][j]);
        }
        if (IsNQueen(queen[i],num[i]))printf(&quot;YES\n&quot;);
        else printf(&quot;NO\n&quot;);
    }
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>思路：因为不在一列上，所以只需验证不在一行上以及不在斜线上。不在一行的验证是找重复，这里用sort再循环比较每连续2个是否相同，也可以搞个visited数组什么的。确实这边开个一维数组queen[200]就够了。这个思路是基于棋子的相对位置想出来的，也可以从棋盘覆盖的角度想。</p>
<hr>
<h2 id="1132-Cut-Integer-20"><a href="#1132-Cut-Integer-20" class="headerlink" title="1132 Cut Integer(20)"></a>1132 Cut Integer(20)</h2><p>Cutting an integer means to cut a K digits lone integer Z into two integers of (K/2) digits long integers A and B. For example, after cutting Z = 167334, we have A = 167 and B = 334. It is interesting to see that Z can be devided by the product of A and B, as 167334 / (167 × 334) = 3. Given an integer Z, you are supposed to test if it is such an integer.<br>Input Specification:<br>Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 20). Then N lines follow, each gives an integer Z (10 ≤ Z &lt;2^31). It is guaranteed that the number of digits of Z is an even number.</p>
<p>Output Specification:<br>For each case, print a single line Yes if it is such a number, or No if not.</p>
<p>Sample Input:</p>
<blockquote>
<p>3<br>167334<br>2333<br>12345678</p>
</blockquote>
<p>Sample Output:</p>
<blockquote>
<p>Yes<br>No<br>No</p>
</blockquote>
<pre><code>//1132 Cut Integer
#include&lt;cstdio&gt;
#include&lt;stdlib.h&gt;
#pragma warning(disable:4996)
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
bool CanWeCutIt(int num){
    int digit = 10;
    int left = 0, right, val, init = num;
    while (digit){//找到位数
        if (num / pow(10, digit-1) &gt; 1)break;
        else digit--;
    }
    for (int i = digit; i &gt; digit / 2; i--){
        val = num / pow(10, i - 1);
        num = num - val*pow(10, i - 1);
        left = left * 10 + val;
    }
    right = init - left*pow(10, digit / 2);
    if (left*right == 0)return false;
    if (init % (left*right) == 0)return true;
    else return false;
}
int main(){
    int N,num;
    scanf(&quot;%d&quot;, &amp;N);
    for (int i = 0; i &lt; N; i++){
        scanf(&quot;%d&quot;, &amp;num);
        if (CanWeCutIt(num))printf(&quot;Yes\n&quot;);
        else printf(&quot;No\n&quot;);
    }
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>思路：数字的思路，看了别人的写法发现还是看作字符串再sscanf比较快一点！</p>
<hr>
<h2 id="1148-Werewolf-Simple-Version-20"><a href="#1148-Werewolf-Simple-Version-20" class="headerlink" title="1148 Werewolf - Simple Version (20)"></a>1148 Werewolf - Simple Version (20)</h2><p>Werewolf（狼人杀） is a game in which the players are partitioned into two parties: the werewolves and the human beings. Suppose that in a game,<br>player #1 said: “Player #2 is a werewolf.”;<br>player #2 said: “Player #3 is a human.”;<br>player #3 said: “Player #4 is a werewolf.”;<br>player #4 said: “Player #5 is a human.”; and<br>player #5 said: “Player #4 is a human.”.<br>Given that there were 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. Can you point out the werewolves?<br>Now you are asked to solve a harder version of this problem: given that there were N players, with 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. You are supposed to point out the werewolves.<br>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N (5≤N≤100). Then N lines follow and the i-th line gives the statement of the i-th player (1≤i≤N), which is represented by the index of the player with a positive sign for a human and a negative sign for a werewolf.<br>Output Specification:</p>
<p>If a solution exists, print in a line in ascending order the indices of the two werewolves. The numbers must be separated by exactly one space with no extra spaces at the beginning or the end of the line. If there are more than one solution, you must output the smallest solution sequence — that is, for two sequences A=a[1],…,a[M] and B=b[1],…,b[M], if there exists 0≤k&lt;M such that a[i]=b[i] (i≤k) and a[k+1]&lt;b[k+1], then A is said to be smaller than B. In case there is no solution, simply print No Solution.<br>Sample Input 1:</p>
<p>5<br>-2<br>+3<br>-4<br>+5<br>+4<br>Sample Output 1:</p>
<blockquote>
<p>1 4</p>
</blockquote>
<p>Sample Input 2:</p>
<blockquote>
<p>6<br>+6<br>+3<br>+1<br>-5<br>-2<br>+4</p>
</blockquote>
<p>Sample Output 2 (the solution is not unique):</p>
<blockquote>
<p>1 5</p>
</blockquote>
<p>Sample Input 3:</p>
<blockquote>
<p>5<br>-2<br>-3<br>-4<br>-5<br>-1</p>
</blockquote>
<p>Sample Output 3:</p>
<blockquote>
<p>No Solution</p>
</blockquote>
<pre><code>//1148werewolf
#pragma warning(disable:4996)
#include&lt;stdlib.h&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
bool WereWolf(int word[], int N,int a, int b){//假设a,b狼人。矛盾即为说谎，判断标准1，说谎的人有一个为狼人 2.2个说谎的人liarwolf = false;
    int  liars = 0, liarwolf = 0;
    for (int i = 0; i &lt; N; i++){//说1是0，说0是1,这里其实word[i]
        if ((abs(word[i]) == a+1 &amp;&amp; word[i]&gt;0 || abs(word[i]) == b+1 &amp;&amp; word[i] &gt; 0) || (abs(word[i]) != a+1 &amp;&amp; abs(word[i]) != b+1 &amp;&amp; word[i]&lt;0)){//liar
            liars++;
            if (i == a || i == b)liarwolf++;
        }
        if (liars &gt; 2 &amp;&amp; liarwolf&gt;1 )return false;
    }
    if (liars == 2 &amp;&amp; liarwolf){
        printf(&quot;%d %d&quot;, a+1, b+1);
        return true;
    }
    else return false;
}
int main(){
    int N,flag=0;
    scanf(&quot;%d&quot;, &amp;N);
    int word[100];
    for (int i = 0; i &lt; N; i++)scanf(&quot;%d&quot;, &amp;word[i]);
    for (int i = 0; i &lt; N - 1 &amp;&amp; !flag; i++) //i,j位为狼人
        for (int j = i + 1; j &lt; N &amp;&amp; !flag; j++)
            if (WereWolf(word,N, i, j))flag = 1;
    if (!flag)printf(&quot;No Solution&quot;);
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>思路：就是枚举两个狼人，这样的话总体的情况是确定的，如果有矛盾就是说谎。(而不是枚举两个说谎者，那样的话麻烦死了)</p>
<hr>
<h1 id="图形输出"><a href="#图形输出" class="headerlink" title="图形输出"></a>图形输出</h1><hr>
<h2 id="知识要点-1"><a href="#知识要点-1" class="headerlink" title="知识要点"></a>知识要点</h2><p>有两种做法。</p>
<ol>
<li>通过规律，直接进行输出。</li>
<li>定义一个二维字符数组，通过规律填充之，然后输出整个二维数组。</li>
</ol>
<hr>
<h2 id="1031-Hello-World-for-U-20"><a href="#1031-Hello-World-for-U-20" class="headerlink" title="1031 Hello World for U(20)"></a>1031 Hello World for U(20)</h2><p>Given any string of N (≥5) characters, you are asked to form the characters into the shape of U. For example, helloworld can be printed as:<br>h&nbsp;&nbsp;&nbsp;d<br>e&nbsp;&nbsp;&nbsp;l<br>l&nbsp;&nbsp;&nbsp; r<br>lowo<br>That is, the characters must be printed in the original order, starting top-down from the left vertical line with n1 characters, then left to right along the bottom line with n2 characters, and finally bottom-up along the vertical line with n3 characters. And more, we would like U to be as squared as possible — that is, it must be satisfied that n1=n3=max { k | k≤n2 for all 3≤n2≤N } with n1 +n2 +n3−2=N.</p>
<p>Input Specification:<br>Each input file contains one test case. Each case contains one string with no less than 5 and no more than 80 characters in a line. The string contains no white space.</p>
<p>Output Specification:<br>For each test case, print the input string in the shape of U as specified in the description.</p>
<p>Sample Input:<br>helloworld!</p>
<p>Sample Output:</p>
<blockquote>
<p>h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!<br>e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d<br>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  l<br>lowor</p>
</blockquote>
<pre><code>//1031 Hello World for U （20 分）
#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#pragma warning(disable:4996)
using namespace std;
int main(){
    string str;
    cin &gt;&gt; str;
    int x = (str.length() + 2) / 3;        //高
    int y = str.length() - 2 * x + 2;        //宽
    for (int i = 0; i &lt; x; i++){
        for (int j = 0; j &lt; y; j++){
            if (i == x - 1)        //最底下那排
                putchar(str[x - 1 + j]);
            else{//其他排
                if (j == 0)putchar(str[i]);
                else if (j == y - 1)printf(&quot;%c\n&quot;,str[str.length() - 1 - i]);
                else putchar(&#39; &#39;);
            }
        }
    }
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>思路：按照排来处理。</p>
<hr>
<h2 id="1105-Spiral-Matrix-25"><a href="#1105-Spiral-Matrix-25" class="headerlink" title="1105 Spiral Matrix(25)"></a>1105 Spiral Matrix(25)</h2><p>This time your job is to fill a sequence of N positive integers into a spiral matrix in non-increasing order. A spiral matrix is filled in from the first element at the upper-left corner, then move in a clockwise spiral. The matrix has m rows and n columns, where m and n satisfy the following: m×n must be equal to N; m≥n; and m−n is the minimum of all the possible values.<br>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N. Then the next line contains N positive integers to be filled into the spiral matrix. All the numbers are no more than 10<br>​4<br>​​ . The numbers in a line are separated by spaces.<br>Output Specification:</p>
<p>For each test case, output the resulting matrix in m lines, each contains n numbers. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line.</p>
<p>Sample Input:</p>
<blockquote>
<p>12<br>37 76 20 98 76 42 53 95 60 81 58 93</p>
</blockquote>
<p>Sample Output:</p>
<blockquote>
<p>98 95 93<br>42 37 81<br>53 20 76<br>58 60 76</p>
</blockquote>
<pre><code>//1105 Spiral Matrix （25 分）
#pragma warning (disable:4996)
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;stdlib.h&gt;
#include&lt;cmath&gt;
using namespace std;
bool cmp(int a, int b){
    return a &gt; b;
}
int main(){
    int N,num[10000];
    scanf(&quot;%d&quot;, &amp;N);
    for (int i = 0; i &lt; N; i++){
        scanf(&quot;%d&quot;, &amp;num[i]);
    }
    sort(num, num +    N,cmp);
    //找最适合长宽,如果从sqrt中间找会更快点
    int row, col;
    for (row = ceil(sqrt(N)); row&lt;=N; row++){
        if (N%row == 0)break;
    }
    col = N / row;
    //output
    int out[200][200],r=row,c=col,start=0,circle,round=0;
    for (int i = 0; i &lt; N; i++){
        circle = r * 2 + c * 2 - 4;
        if (i - start &lt; c)out[round][round+i-start] = num[i];
        else if (i - start &lt; r + c - 1)out[round + i - start - c + 1][round+ c - 1] = num[i];
        else if (i - start &lt; r + 2 * c - 2)out[round+r - 1][round+c-(i-start-r-c+1)-2] = num[i];
        else if (i - start &lt; circle - 1)out[round+r - (i - start - r - 2 * c + 4)][round] = num[i];
        else {//i-start==circle-1
            out[round+r - (i - start - r - 2 * c + 4)][round] = num[i];
            start += circle;
            round++;
            r -= 2;
            c -= 2;
        }
    }
    for (int i = 0; i &lt; row; i++){
        for (int j = 0; j &lt; col; j++){
            printf(&quot;%d&quot;, out[i][j]);
            if (j != col - 1)printf(&quot; &quot;);
            else printf(&quot;\n&quot;);
        }
    }
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>我……我写的好粗暴啊……不想优化这边一大坨了……<br>emmmm其实这边的输出是一个连续的过程，每两个之间就是行或列差1，限定边界不断++改变方向就可以了。（四种方向下的行列下标都是相关的，没必要搞这么多参数我哭太傻了（我就一心要把螺旋的展平了用数学式来描述了远不如别人搞自动++的简单。<br>更优雅的写法：<a href="https://blog.csdn.net/richenyunqi/article/details/79530619" target="_blank" rel="noopener">https://blog.csdn.net/richenyunqi/article/details/79530619</a><br>我好菜啊。</p>
<hr>
<h1 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h1><hr>
<h2 id="知识要点-2"><a href="#知识要点-2" class="headerlink" title="知识要点"></a>知识要点</h2><ul>
<li>日数据的话可以自己写函数比较，也可读入字符串用字符串比较函数，也可转化为分/秒直接进行比较。</li>
<li>年数据要考虑平年闰年，大小月等。</li>
<li>下面这两道题也可以放在排序那里。</li>
<li>可以看下1016的时间处理。</li>
</ul>
<hr>
<h2 id="1006-Sign-In-and-Sign-Out-25"><a href="#1006-Sign-In-and-Sign-Out-25" class="headerlink" title="1006 Sign In and Sign Out(25)"></a>1006 Sign In and Sign Out(25)</h2><p>At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day.<br>Input Specification:<br>Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format:</p>
<blockquote>
<p>ID_number Sign_in_time Sign_out_time</p>
</blockquote>
<p>where times are given in the format HH:MM:SS, and ID_number is a string with no more than 15 characters.</p>
<p>Output Specification:<br>For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.<br>Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.</p>
<p>Sample Input:</p>
<blockquote>
<p>3<br>CS301111 15:30:28 17:00:10<br>SC3021234 08:00:00 11:25:25<br>CS301133 21:45:00 21:58:40</p>
</blockquote>
<p>Sample Output:</p>
<blockquote>
<p>SC3021234 CS301133</p>
</blockquote>
<pre><code>//1006 Sign In and Sign Out
#pragma warning(disable:4996)
#include&lt;cstdio&gt;
#include&lt;stdlib.h&gt;
struct time{
    int hour;
    int minute;
    int second;
};
struct item{
    char IDnumber[15];
    time in;
    time out;
};
bool cmptime(time a,time b){//a is earlier than b.
    if (a.hour &lt; b.hour)return true;
    else if (a.hour&gt;b.hour)return false;
    else if (a.minute &lt; b.minute)return true;
    else if (a.minute&gt;b.minute)return false;
    else if (a.second &lt; b.second)return true;
    else return false;
}
int main(){
    //input
    int num;//number of items
    scanf(&quot;%d&quot;, &amp;num);
    item item1[1000];
    int early=0, late=0;//index of the earliest,latest
    for (int i = 0; i &lt; num; i++){
        scanf(&quot;%s %d:%d:%d %d:%d:%d&quot;, &amp;item1[i].IDnumber, &amp;item1[i].in.hour, &amp;item1[i].in.minute, &amp;item1[i].in.second, &amp;item1[i].out.hour, &amp;item1[i].out.minute, &amp;item1[i].out.second);
        //in-early
        if (cmptime(item1[i].in, item1[early].in))early = i;
        //out-late
        if (cmptime(item1[late].out, item1[i].out))late = i;
    }
    printf(&quot;%s %s&quot;, item1[early].IDnumber, item1[late].IDnumber);
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>简单模拟题，有点时间处理的要素就单独归一类了，时间处理类的题感觉就是结构体一箩筐。<br>思路：问题是找最早和最迟的，先定义结构体表示item和time，定义比较时间的函数，最后循环一次跑出最早最迟。</p>
<ol>
<li>适当简化变量名字（我从一个字母定义变量一团糊以后，痛改前非成了罗里吧嗦又臭又长裹脚布式变量名）。</li>
<li>局部变量没初始化——scanf是不是忘记加&amp;了。</li>
<li>记得加return0啊。</li>
<li>考虑到时间复杂度，可以在读入的循环中直接进行比较。</li>
<li>也可以把时间统一度量成多少分钟这样，或者直接读入字符串，用字符串strcmp直接比就不用写time的比较函数了。</li>
</ol>
<p>2.16这个cmptime函数写的好傻啊</p>
<hr>
<h2 id="1017-Queueing-at-Bank-25"><a href="#1017-Queueing-at-Bank-25" class="headerlink" title="1017 Queueing at Bank(25)"></a>1017 Queueing at Bank(25)</h2><p>Suppose a bank has K windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. All the customers have to wait in line behind the yellow line, until it is his/her turn to be served and there is a window available. It is assumed that no window can be occupied by a single customer for more than 1 hour.<br>Now given the arriving time T and the processing time P of each customer, you are supposed to tell the average waiting time of all the customers.<br>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains 2 numbers: N (≤10^​4) - the total number of customers, and K (≤100) - the number of windows. Then N lines follow, each contains 2 times: HH:MM:SS - the arriving time, and P - the processing time in minutes of a customer. Here HH is in the range [00, 23], MM and SS are both in [00, 59]. It is assumed that no two customers arrives at the same time.<br>Notice that the bank opens from 08:00 to 17:00. Anyone arrives early will have to wait in line till 08:00, and anyone comes too late (at or after 17:00:01) will not be served nor counted into the average.<br>Output Specification:<br>For each test case, print in one line the average waiting time of all the customers, in minutes and accurate up to 1 decimal place.</p>
<p>Sample Input:</p>
<blockquote>
<p>7 3<br>07:55:00 16<br>17:00:01 2<br>07:59:59 15<br>08:01:00 60<br>08:00:00 30<br>08:00:02 2<br>08:03:00 10</p>
</blockquote>
<p>Sample Output:</p>
<blockquote>
<p>8.2</p>
</blockquote>
<pre><code>//1017 Queueing at Bank （25 分）
#pragma warning(disable:4996)
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
struct custom{
    float arrivetime;
    float processtime;
};
bool cmp(custom a, custom b){//别写错了 不是if（）return a&lt;b那得运算符重载了，这里就等于定义排序规则就是按照arrivetime排的
    return a.arrivetime &lt; b.arrivetime;
}
int main(){
    //input
    int N,customs, windows,hh,mm,ss,temp;
    custom list[10000];
    float window[100];//存储结束时间
    scanf(&quot;%d %d&quot;, &amp;N, &amp;windows);
    fill(window, window + windows, 480);
    customs =0;
    for (int i = 0; i &lt; N; i++){
        scanf(&quot;%d:%d:%d %d&quot;, &amp;hh, &amp;mm, &amp;ss, &amp;temp);
        float time = hh * 3600 + mm * 60 + ss;//否则对秒不敏感
        if (time &lt;= 61200){//别一个读了另一个没读
            list[customs].arrivetime = time / 60;
            list[customs].processtime = temp;
            customs++;
        }
    }
    sort(list, list + customs, cmp);
    //open door
    float  sumtime = 0;
    int nextindex = -1;
    for (int order = 0; order &lt; customs; order++){
        //找最快窗口
        float nexttime = 9999;//每次都得设置
        for (int i = 0; i &lt; windows; i++){
            if (window[i] &lt; nexttime){
                nextindex = i;
                nexttime = window[i];
            }
        }
        if (list[order].arrivetime&gt;=nexttime){//空闲直接可用,无等待时间
            window[nextindex] = list[order].arrivetime + list[order].processtime;
        }
        else{//忙碌等待中，包括提早到的情况
            window[nextindex] = nexttime + list[order].processtime;
            sumtime += nexttime - list[order].arrivetime;//包括早到了
        }
    }
    printf(&quot;%.1f&quot;, sumtime / customs);
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>模拟窗口办理业务的情况。思路是读入数据时去掉迟到顾客，按顾客循环先到先找最快的窗口，然后根据窗口空闲与否分别更新窗口情况以及总等待时间。</p>
<ol>
<li>注意下这里结构体排序比较函数的写法</li>
<li>写的时候本来想用set但是是有去重就没用，现在一看好像还可以用multiset和priority_queue这种容器，本身排队的题用queue写应该就是很直观的，这道题会在题目集4中用STL重写。</li>
</ol>
<hr>
<h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><hr>
<h2 id="知识要点-3"><a href="#知识要点-3" class="headerlink" title="知识要点"></a>知识要点</h2><ul>
<li><p>X进制数转十进制</p>
<pre><code>int y=0,product=1;
while(num!=0){
  y+=(num%10)*product;//num%10求个位
  product*=x;
}
</code></pre><ul>
<li><p>十进制数转X进制</p>
<p>  do{</p>
<pre><code>digit[k++]=num%X;
num=num/x;
</code></pre><p>  }while(num!=0);//do while而不是while是为了防止0时的错误。倒着输出！</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="1019-General-Palindromic-Number-20"><a href="#1019-General-Palindromic-Number-20" class="headerlink" title="1019 General Palindromic Number(20)"></a>1019 General Palindromic Number(20)</h2><p>A number that will be the same when it is written forwards or backwards is known as a Palindromic Number. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers.<br>Although palindromic numbers are most often considered in the decimal system, the concept of palindromicity can be applied to the natural numbers in any numeral system. Consider a number N&gt;0 in base b≥2, where it is written in standard notation with k+1 digits. Here, as usual, 0≤ai&lt;b for all i and ak is non-zero. Then N is palindromic if and only if ai =ak−i for all i. Zero is written 0 in any base and is also palindromic by definition.<br>Given any positive decimal integer N and a base b, you are supposed to tell if N is a palindromic number in base b.</p>
<p>Input Specification:<br>Each input file contains one test case. Each case consists of two positive numbers N and b, where 0&lt;N≤10^9<br>​​  is the decimal number and 2≤b≤10^9 is the base. The numbers are separated by a space.</p>
<p>Output Specification:<br>For each test case, first print in one line Yes if N is a palindromic number in base b, or No if not. Then in the next line, print N as the number in base b in the form “a​kak−1 … a0 “. Notice that there must be no extra space at the end of output.</p>
<p>Sample Input 1:</p>
<blockquote>
<p>27 2</p>
</blockquote>
<p>Sample Output 1:</p>
<blockquote>
<p>Yes<br>1 1 0 1 1</p>
</blockquote>
<p>Sample Input 2:</p>
<blockquote>
<p>121 5</p>
</blockquote>
<p>Sample Output 2:</p>
<blockquote>
<p>No<br>4 4 1</p>
</blockquote>
<pre><code>//1019 General Palindromic Number
#pragma warning(disable:4996)
#include&lt;cstdio&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;cstdlib&gt;
using namespace std;
bool IsPalindromic(int digit[], int i){
    for (int j = 0; j &lt; i / 2; j++){
        if (digit[j] != digit[i -1- j])return false;
    }
    return true;
}
int main(){
    int num, base;
    scanf(&quot;%d %d&quot;, &amp;num, &amp;base);
    int digit[129];
    int i = 0;
    do{
        digit[i] = num%base;
        i++;
        num = num / base;
    } while (num != 0);
    if (IsPalindromic(digit, i))printf(&quot;Yes\n&quot;);
    else printf(&quot;No\n&quot;);
    printf(&quot;%d&quot;, digit[i-1]);
    i-=2;
    for (; i &gt;= 0; i--)
        printf(&quot; %d&quot;, digit[i]);
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>简单题。</p>
<h2 id="1027-Colors-in-Mars-20"><a href="#1027-Colors-in-Mars-20" class="headerlink" title="1027 Colors in Mars (20)"></a>1027 Colors in Mars (20)</h2><p>People in Mars represent the colors in their computers in a similar way as the Earth people. That is, a color is represented by a 6-digit number, where the first 2 digits are for Red, the middle 2 digits for Green, and the last 2 digits for Blue. The only difference is that they use radix 13 (0-9 and A-C) instead of 16. Now given a color in three decimal numbers (each between 0 and 168), you are supposed to output their Mars RGB values.</p>
<p>Input Specification:<br>Each input file contains one test case which occupies a line containing the three decimal color values.</p>
<p>Output Specification:<br>For each test case you should output the Mars RGB value in the following format: first output #, then followed by a 6-digit number where all the English characters must be upper-cased. If a single color is only 1-digit long, you must print a 0 to its left.</p>
<p>Sample Input:</p>
<blockquote>
<p>15 43 71</p>
</blockquote>
<p>Sample Output:</p>
<blockquote>
<h1 id="123456"><a href="#123456" class="headerlink" title="123456"></a>123456</h1></blockquote>
<pre><code>//1027 Colors in Mars
#pragma warning(disable:4996)
#include&lt;cstdio&gt;
#include&lt;string.h&gt;
#include&lt;cstdlib&gt;
int main(){
    int color[3];
    scanf(&quot;%d %d %d&quot;, &amp;color[0], &amp;color[1], &amp;color[2]);
    char radix[14] = &quot;0123456789ABC&quot;;
    printf(&quot;#&quot;);
    for (int i = 0; i &lt; 3; i++){
        char num[2];
        int k = 0;
        do{
            num[k++] = radix[color[i] % 13];
            color[i] = color[i] / 13;
        } while (color[i] != 0);
        if (k == 1)printf(&quot;0%c&quot;, num[0]);
        else printf(&quot;%c%c&quot;, num[1], num[0]);
    }
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>简单题。</p>
<hr>
<h2 id="1058-A-B-in-Hogwarts-20"><a href="#1058-A-B-in-Hogwarts-20" class="headerlink" title="1058 A+B in Hogwarts(20)"></a>1058 A+B in Hogwarts(20)</h2><p>If you are a fan of Harry Potter, you would know the world of magic has its own currency system — as Hagrid explained it to Harry, “Seventeen silver Sickles to a Galleon and twenty-nine Knuts to a Sickle, it’s easy enough.” Your job is to write a program to compute A+B where A and B are given in the standard form of Galleon.Sickle.Knut (Galleon is an integer in [0,10^7 ], Sickle is an integer in [0, 17), and Knut is an integer in [0, 29)).<br>Input Specification:<br>Each input file contains one test case which occupies a line with A and B in the standard form, separated by one space.<br>Output Specification:<br>For each test case you should output the sum of A and B in one line, with the same format as the input.</p>
<p>Sample Input:</p>
<blockquote>
<p>3.2.1 10.16.27</p>
</blockquote>
<p>Sample Output:</p>
<blockquote>
<p>14.1.28</p>
</blockquote>
<pre><code>//1058 A+B in Hogwarts
#pragma warning(disable:4996)
#include&lt;cstdio&gt;
#include&lt;string.h&gt;
#include&lt;cstdlib&gt;
long long trans1(long long a, long long b, long long c){
    return a * 17 * 29 + b * 29 + c;
}
void trans2(long long sum, long long &amp;a, long long&amp;b, long long&amp;c){
    a = sum / (17 * 29);
    sum -= a * 17 * 29;
    b = sum / 29;
    c = sum % 29;
}
int main(){
    long long hogwarts[2][3];
    for (int i = 0; i &lt; 2;i++)
        scanf(&quot;%lld.%lld.%lld&quot;, &amp;hogwarts[i][0], &amp;hogwarts[i][1], &amp;hogwarts[i][2]);
    long long sum;
    sum = trans1(hogwarts[0][0], hogwarts[0][1], hogwarts[0][2]) + trans1(hogwarts[1][0], hogwarts[1][1], hogwarts[1][2]);
    long long galleon, sickle, knut;
    trans2(sum, galleon, sickle, knut);
    printf(&quot;%lld.%lld.%lld&quot;, galleon, sickle, knut);
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>这边统一度量以后有一个边界溢出问题，需要把所有的都转成long long。更简单的思路是两个一加逢x进位。</p>
<hr>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="http://www.wusanwan.xyz">吴三万</a>
            <p>原文链接：<a href="http://www.wusanwan.xyz/2019/07/05/PAT甲级题目集1-简单模拟/">http://www.wusanwan.xyz/2019/07/05/PAT甲级题目集1-简单模拟/</a>
            <p>发表日期：<a href="http://www.wusanwan.xyz/2019/07/05/PAT甲级题目集1-简单模拟/">July 5th 2019, 11:34:44 am</a>
            <p>更新日期：<a href="http://www.wusanwan.xyz/2019/07/05/PAT甲级题目集1-简单模拟/">December 28th 2019, 11:35:06 pm</a>
            <p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2019/07/08/PAT甲级题目集2-字符串处理/" title= "PAT甲级题目集2-字符串处理">
                    <div class="nextTitle">PAT甲级题目集2-字符串处理</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2019/06/04/CrashCourse学习技能笔记/" title= "CrashCourse学习技能笔记">
                    <div class="prevTitle">CrashCourse学习技能笔记</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <div id="comment"></div>
    <script>
    new Valine({
        el: '#comment' ,
        notify:false, 
        verify:false, 
        appId: "LBBQupBMJM5xUoIbNjmi43JO-gzGzoHsz",
        appKey: "zs5uR8OAi9BWaa9pQGtewrFj",
        placeholder: "来侃大山",
        path:window.location.pathname, 
        avatar:'mm' 
    });
    </script>


    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:wuwenxi_2011@126.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/wusanwan" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="https://www.douban.com/people/147344298/" class="iconfont-archer douban" target="_blank" title=douban></a>
            
        
    
        
    
        
    
        
            
                <a href="https://instagram.com/sanw5win7" class="iconfont-archer instagram" target="_blank" title=instagram></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="/绿鲤鱼与驴三万" class="iconfont-archer steam" target="_blank" title=steam></a>
            
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    <br>
    <!-- 计时  用一个css-->

      <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
  <script>
      var now = new Date();
      function createtime() {
          var grt= new Date("09/21/2018 13:21:12");//此处修改你的建站时间或者网站上线时间
          now.setTime(now.getTime()+250);
          days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
          if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
          mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
          snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
          document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
          document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
      }
  setInterval("createtime()",250);
  </script>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
    
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    


</footer>

    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#简单模拟"><span class="toc-number">1.</span> <span class="toc-text">简单模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#知识要点"><span class="toc-number">1.1.</span> <span class="toc-text">知识要点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1002-A-B-for-Polynomials-25"><span class="toc-number">1.2.</span> <span class="toc-text">1002 A+B for Polynomials(25)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1008-Elevator-20"><span class="toc-number">1.3.</span> <span class="toc-text">1008 Elevator(20)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1009-Product-of-Polynomials-25"><span class="toc-number">1.4.</span> <span class="toc-text">1009 Product of Polynomials(25)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1011-World-Cup-Betting-20"><span class="toc-number">1.5.</span> <span class="toc-text">1011 World Cup Betting(20)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1036-Boys-vs-Girls-25"><span class="toc-number">1.6.</span> <span class="toc-text">1036 Boys vs Girls(25)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1042-Shuffling-Machine-20"><span class="toc-number">1.7.</span> <span class="toc-text">1042 Shuffling Machine(20)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1046-Shortest-Distance-20"><span class="toc-number">1.8.</span> <span class="toc-text">1046 Shortest Distance(20)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1049-Counting-Ones-30"><span class="toc-number">1.9.</span> <span class="toc-text">1049 Counting Ones(30)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1069-The-Black-Hole-of-Numbers-20"><span class="toc-number">1.10.</span> <span class="toc-text">1069 The Black Hole of Numbers(20)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1093-Count-PAT’s-25"><span class="toc-number">1.11.</span> <span class="toc-text">1093 Count PAT’s (25)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1104-Sum-of-Number-Segments-20"><span class="toc-number">1.12.</span> <span class="toc-text">1104 Sum of Number Segments(20)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1109-Group-Photo-25"><span class="toc-number">1.13.</span> <span class="toc-text">1109 Group Photo(25)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1113-Integer-Set-Partition-25"><span class="toc-number">1.14.</span> <span class="toc-text">1113 Integer Set Partition (25)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1117-Eddington-Number-25"><span class="toc-number">1.15.</span> <span class="toc-text">1117 Eddington Number(25)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1128-N-Queens-Puzzle-20"><span class="toc-number">1.16.</span> <span class="toc-text">1128 N Queens Puzzle(20)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1132-Cut-Integer-20"><span class="toc-number">1.17.</span> <span class="toc-text">1132 Cut Integer(20)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1148-Werewolf-Simple-Version-20"><span class="toc-number">1.18.</span> <span class="toc-text">1148 Werewolf - Simple Version (20)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#图形输出"><span class="toc-number">2.</span> <span class="toc-text">图形输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#知识要点-1"><span class="toc-number">2.1.</span> <span class="toc-text">知识要点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1031-Hello-World-for-U-20"><span class="toc-number">2.2.</span> <span class="toc-text">1031 Hello World for U(20)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1105-Spiral-Matrix-25"><span class="toc-number">2.3.</span> <span class="toc-text">1105 Spiral Matrix(25)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#时间处理"><span class="toc-number">3.</span> <span class="toc-text">时间处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#知识要点-2"><span class="toc-number">3.1.</span> <span class="toc-text">知识要点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1006-Sign-In-and-Sign-Out-25"><span class="toc-number">3.2.</span> <span class="toc-text">1006 Sign In and Sign Out(25)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1017-Queueing-at-Bank-25"><span class="toc-number">3.3.</span> <span class="toc-text">1017 Queueing at Bank(25)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进制转换"><span class="toc-number">4.</span> <span class="toc-text">进制转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#知识要点-3"><span class="toc-number">4.1.</span> <span class="toc-text">知识要点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1019-General-Palindromic-Number-20"><span class="toc-number">4.2.</span> <span class="toc-text">1019 General Palindromic Number(20)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1027-Colors-in-Mars-20"><span class="toc-number">4.3.</span> <span class="toc-text">1027 Colors in Mars (20)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#123456"><span class="toc-number">5.</span> <span class="toc-text">123456</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1058-A-B-in-Hogwarts-20"><span class="toc-number">5.1.</span> <span class="toc-text">1058 A+B in Hogwarts(20)</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 27
        </div>
        <!-- search  -->
        
            <div class="site-search popup-trigger">
                <span class="iconfont-archer search-icon">&#xe627;</span>
            </div>
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/23</span><a class="archive-post-title" href= "/2020/02/23/越王勾践分析/" >越王勾践分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/20</span><a class="archive-post-title" href= "/2020/02/20/基于pyecharts的专注时间日历图生成脚本/" >基于pyecharts的专注时间日历图生成脚本</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/19</span><a class="archive-post-title" href= "/2020/02/19/爬虫实战之晋江榜单抓取以及数据分析/" >🕷爬虫实战之晋江榜单抓取以及数据分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/30</span><a class="archive-post-title" href= "/2020/01/30/CS61A/" >CS61A</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/17</span><a class="archive-post-title" href= "/2019/12/17/学过的在线课程/" >学过的在线课程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/18</span><a class="archive-post-title" href= "/2019/07/18/PAT甲级题目集6-数学问题/" >PAT甲级题目集6-数学问题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/17</span><a class="archive-post-title" href= "/2019/07/17/PAT甲级题目集4-散列，二分法，two-pointers/" >PAT甲级题目集4-散列，二分法，two-pointers</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/17</span><a class="archive-post-title" href= "/2019/07/17/PAT甲级题目集5-STL/" >PAT甲级题目集5-STL</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/13</span><a class="archive-post-title" href= "/2019/07/13/PAT甲级题目集3-排序和贪心/" >PAT甲级题目集3-排序和贪心</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/08</span><a class="archive-post-title" href= "/2019/07/08/PAT甲级题目集2-字符串处理/" >PAT甲级题目集2-字符串处理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/05</span><a class="archive-post-title" href= "/2019/07/05/PAT甲级题目集1-简单模拟/" >PAT甲级题目集1-简单模拟</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/04</span><a class="archive-post-title" href= "/2019/06/04/CrashCourse学习技能笔记/" >CrashCourse学习技能笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/30</span><a class="archive-post-title" href= "/2019/05/30/openGL海绵宝宝小游戏/" >openGL海绵宝宝小游戏</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/04</span><a class="archive-post-title" href= "/2019/05/04/图形学基础实验/" >图形学基础实验</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/03</span><a class="archive-post-title" href= "/2019/04/03/Python实现微信机器人/" >基于Python wxpy库 的微信改造</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/02</span><a class="archive-post-title" href= "/2019/03/02/越努力越菜鸡/" >PAT乙感想越学越菜🐔+PAT乙级题目目录</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/28</span><a class="archive-post-title" href= "/2019/02/28/PAT乙级题目集4-数学问题-STL-链表/" >PAT乙级题目集4 数学问题 STL 链表</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/23</span><a class="archive-post-title" href= "/2019/02/23/git学习实验报告/" >git入门报告</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/22</span><a class="archive-post-title" href= "/2019/02/22/PAT乙级题目集3-贪心-散列-two-pointers-二分/" >PAT乙级题目集3  贪心 散列 二分法 two pointers</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/21</span><a class="archive-post-title" href= "/2019/02/21/PAT乙级题目集2-字符串处理/" >PAT乙级题目集2 字符串处理 排序</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/18</span><a class="archive-post-title" href= "/2019/02/18/PAT乙级题目集1-简单模拟/" >PAT乙级题目集1 简单模拟</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/01</span><a class="archive-post-title" href= "/2019/02/01/通过两地经纬度计算距离/" >通过经纬度计算两地距离</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/11</span><a class="archive-post-title" href= "/2018/11/11/LaTeX一些要注意的地方/" >LaTeX错误合集❗</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/11</span><a class="archive-post-title" href= "/2018/11/11/文献管理与信息分析课程笔记/" >《文献管理与信息分析》课程笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/09</span><a class="archive-post-title" href= "/2018/11/09/科研工具一网打尽/" >科研工具一网打尽😎</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/22</span><a class="archive-post-title" href= "/2018/10/22/论文笔记 GSR-TNNM/" >论文笔记：Truncated Nuclear Norm Minimization Based Group Sparsity Representation For Image Restoration</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/21</span><a class="archive-post-title" href= "/2018/09/21/BLOG搭建/" >BLOG搭建</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="打卡"><span class="iconfont-archer">&#xe606;</span>打卡</span>
    
        <span class="sidebar-tag-name" data-tags="blog"><span class="iconfont-archer">&#xe606;</span>blog</span>
    
        <span class="sidebar-tag-name" data-tags="LaTeX"><span class="iconfont-archer">&#xe606;</span>LaTeX</span>
    
        <span class="sidebar-tag-name" data-tags="算法"><span class="iconfont-archer">&#xe606;</span>算法</span>
    
        <span class="sidebar-tag-name" data-tags="PAT"><span class="iconfont-archer">&#xe606;</span>PAT</span>
    
        <span class="sidebar-tag-name" data-tags="玩具"><span class="iconfont-archer">&#xe606;</span>玩具</span>
    
        <span class="sidebar-tag-name" data-tags="python"><span class="iconfont-archer">&#xe606;</span>python</span>
    
        <span class="sidebar-tag-name" data-tags="openGL"><span class="iconfont-archer">&#xe606;</span>openGL</span>
    
        <span class="sidebar-tag-name" data-tags="图形学"><span class="iconfont-archer">&#xe606;</span>图形学</span>
    
        <span class="sidebar-tag-name" data-tags="git"><span class="iconfont-archer">&#xe606;</span>git</span>
    
        <span class="sidebar-tag-name" data-tags="工具"><span class="iconfont-archer">&#xe606;</span>工具</span>
    
        <span class="sidebar-tag-name" data-tags="MOOC"><span class="iconfont-archer">&#xe606;</span>MOOC</span>
    
        <span class="sidebar-tag-name" data-tags="cs"><span class="iconfont-archer">&#xe606;</span>cs</span>
    
        <span class="sidebar-tag-name" data-tags="图像处理"><span class="iconfont-archer">&#xe606;</span>图像处理</span>
    
        <span class="sidebar-tag-name" data-tags="论文"><span class="iconfont-archer">&#xe606;</span>论文</span>
    
        <span class="sidebar-tag-name" data-tags="感悟"><span class="iconfont-archer">&#xe606;</span>感悟</span>
    
        <span class="sidebar-tag-name" data-tags="Matlab"><span class="iconfont-archer">&#xe606;</span>Matlab</span>
    
        <span class="sidebar-tag-name" data-tags="coursera"><span class="iconfont-archer">&#xe606;</span>coursera</span>
    
        <span class="sidebar-tag-name" data-tags="爬虫"><span class="iconfont-archer">&#xe606;</span>爬虫</span>
    
        <span class="sidebar-tag-name" data-tags="数据分析"><span class="iconfont-archer">&#xe606;</span>数据分析</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="PAT"><span class="iconfont-archer">&#xe60a;</span>PAT</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "吴三万"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
        <div class="site-search">
  <div class="algolia-popup popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="iconfont-archer">&#xe609;</i>
    </span>
  </div>
</div>
        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.8.0/dist/instantsearch.min.js" defer></script>
        <script src="/scripts/search.js" defer></script>
    
    <!-- busuanzi  -->
    
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"scale":0.7,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":-80},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":1,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body>
</html>


